2021.4.11
#### 1 熔断限流（本质是保护系统）
   1）限流熔断：资源、规划、计算逻辑
    1.1）常用的限流算法
        1.1.1）计数法：这种方法最暴力也最直接，规定一个时间窗口，比如规定每秒请求数为1000，当请求数小于1000时放行，
            大于则拒绝。
        1.1.2）滑动时间窗口：这种方法将计数法的时间窗口平均分成多个（每个窗口单独看就是计数法），每个窗口代表一段时间，
            随着时间的推移将最老的窗口过期掉，加入新的窗口，看起来每次只移动一个时间窗口（如上一个历史窗口请求数还有600，
            新窗口请求数500，则被拒绝掉，因600+500>1000，解决了计数法存在的问题）。
            存在问题：滑动时间窗口的限流精度取决于时间窗口的精度，如果时间窗口太大同样起不到限流的作用。
                比如在starTime+400毫秒有600个请求，在startTime+1400毫秒的时候新加入600个请求，那么新加入的请求是否
                应该被限制？如果窗口的时间跨度为500毫秒，那么算法就不会限制，如果窗口的时间跨度为200毫秒，那么就会限制。
        1.1.3）漏桶算法：假如用流水的速度来类比请求的速度，我们用一个蓄水池（漏桶）来存储当前的请求量，我们假设水流入漏桶
            的速度不限，流出的速度恒定，那么超过漏桶的容量时，水自然会溢出（代表请求被拒绝），不超过容量时漏桶以恒定的速度
            向下出水（代表以固定的速度发出请求）。
        1.1.4）令牌桶算法：令牌桶算法和漏桶算法看起来类似，其实是两个完全不同的设计思路。我们知道，现实场景中流量都不是
            以恒定的速度过来的，如果我们能够在限制最大流量的同时又能够处理突发的流量那就比较好了。令牌桶算法就完美解决了
            这个问题。假如，水流入桶的速度恒定（以恒定的速度加令牌），流出的速度不确定（对应流量的不确定性），只有桶内有
            水的情况才能够流出（请求时先获取令牌，几个请求就获取几个令牌）。
            从形式上看，如果把漏桶倒过来就是令牌桶了。两者最大的区别就是令牌桶能应对突发流量，更加接近现实场景。这个如何
            理解？假如：漏桶的出水速率是10/秒，桶的最大容量为100，当有20个请求过来时，漏桶只能放行10个，另外10个需要等待，
            但是令牌桶却可以同时放行这20个请求。
            令牌桶的Maven依赖：guava 18.0 // 谷歌的
#### 2 guava限流使用
   RateLimiter是令牌桶思想的一个实现，可实现流量整形、资源访问速率控制。                       
    