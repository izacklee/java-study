2021.2.7
#### 1 Spring事务（一般说的是数据库的事务）
   1）数据库事务的特性ACID
    1.1）原子性：要么都成功，要么都失败；
    1.2）一致性：事务执行前后数据保持一致，如：a+b=10，不管a和b怎么变，最终相加还是等于10；
    1.3）隔离性：并发的事务之间互不影响，如A赚100元给B未提交，B是看不到增加的100元的；
        （串行化：都不允许，每个事务都是独立执行，比如事务A1和A2，A2只能在A1执行前或者执行后执行。）
    1.4）持久性：将数据保存到数据库上，永久不丢失。
   2）数据库存储引擎通常使用InnoDB，因为对并发支持比较高。
    事务的隔离性通过数据库锁的机制实现，持久性通过redo log（重做日志）来实现，原子性和一致性通过
    Undo log（撤销日志）来实现。 
   3）事务并发带来的问题
    3.1）脏读：未提交读，读到了未提交的数据（事务A修改数据未提交，事务B读到了），可能造成操作不正确；
    3.2）丢失修改：事务1和事务2都读到的同一个数据，事务1修改了数据后，事务2也修改该数据了，然后导致事务1的修改结果被丢失。
        如：事务1读取某表中的数据A=10，事务2也读取了A=10，事务1修改A=A-2，事务2也修改A=A-2，最终结果A=8（实际应
        该为A=6才对），事务1的修改被丢失。
    3.3）不可重复读：在一个事务内两次读取数据，两次读到的数据不一致。
        不可重复读，将导致以下1和3步骤查询读到的数据可能不一致
        // A 
        // autoCommit
        // SELECT * FROM table_a WHERE id = 100;   1   10
        // ...
        // SELECT * FROM table_a WHERE id = 100;   3   50
        // commit
        // B 
        // UPDATE table_a SET xxx = xxx WHERE id = 100;   2 
    3.4）幻读（与不可重复读类似）：在一个事务里边读到了不存在的数据，如当事务1读了一些数据，事务2紧接着插入一些数据，
        导致事务1随后多读了一些原本不存在的数据，就好像幻觉一样。
        // A 
        // autoCommit
        // SELECT * FROM table_a WHERE id > 100;   1   100
        // ...
        // SELECT * FROM table_a WHERE id > 100;   3   102
        // commit
        // B
        // INSERT INTO table_a (id) VALUES (1009);  2
        // INSERT INTO table_a (id) VALUES (1010);  2   
   4）不可重复读VS幻读 
    4.1）不可重复读的重点是修改，幻读的重点在于新增或者删除
   5）数据库事务的隔离级别（四个隔离级别）
    5.1）READ-UNCOMMITTED（未提交读）：最低的隔离级别，会造成脏读、幻读或不可重复读；
    5.2）READ-COMMITTED（已提交读）：读取并发事务已提交的数据，可避免脏读，但还是会存在幻读或不可重复读；
    5.3）REPEATABLE-READ（可重复读）：InnoDB存储引擎默认的隔离级别，在一个事务内，多次读取数据，读到的数据都是一致的，
        可避免脏读和不可重复读，但是幻读还是存在；
    5.4）SERIALIZABLE（串行化）：最高的隔离级别，所有事务都是单个依次执行（性能差），互不干扰，可解决脏读、不可重复读或幻读。
    在效率和并发性能做取舍时，一般会选择READ-COMMITTED（已提交读）隔离级别，因为性能最优，然后自己再去解决不可重复读或
    幻读的问题。 
    解决不可重复读，比如加共享锁（多个数据共享一把锁，只能查不能改和删）,
        例句：SELECT * FROM dept_auxiliary WHERE deptno = 201 LOCK IN SHARE MODE; 
    解决幻读，比如增加行的版本号，给每一批数据增加独立的版本号，这样用共享锁（避免删）+版本号（避免增）就可以解决了。
   6）Spring事务传播特性
    通过@Transactional（Spring声明式事务 只有在public修饰符方法上才能生效 因为动态代理通过接口实现的 所以非public
    修饰符的方法自然不支持）注解实现，可设置不同的传播特性，值为0-6。
    伪代码：
        // 1 start
        // 2 autoCommit(false)
        // 3 xxx  // 业务代码
        // 4 commit
        // 5 rollback 
     jdk动态代理为什么必须是基于接口实现的？
     因为jdk动态代理生成的class文件已经继承了Proxy，而java是单继承的，所以是基于jdk动态代理是基于接口的。        