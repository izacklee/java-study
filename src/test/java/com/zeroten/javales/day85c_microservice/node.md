2021.3.23
#### 1 高性能索引策略
   如何看查询效率？看执行计划列的值，比如说是否和预期一样用到了索引，效率是不是高。
   1）执行计划（EXPLAIN）
    a EXPLAIN SELECT * FROM hjmall_pond_log
    b EXPLAIN SELECT COUNT(*) FROM hjmall_pond_log 
    这两语句执行结果的区别a会查询所有的列，而b只会查询总的个数，b换句话说存什么不关心，只要有就行，而a是要知道的。
   2）当条件有and的时候，如果可以建议建“联合索引“
   3）尽量不要用可变长度类型字段做索引，因为索引长度会很长，占内存，如：char、varchar。
#### 2 SQL优化建议
   1）不要写得太复杂，比如关联表超过3张；
   2）使用临时表缓存中间结果，避免多次扫描主表；
   3）使用like的时候要注意是否会导致全表扫描，关键词“%abc%”，由于abd前加了"%"，因此该查询会导致全表扫描，除非必要，
      否则不要在关键词前加"%"，要加后面；
   4）尽量避免使用not in，!=或<>操作符，因引擎会放弃使用索引而进行全表扫描，可用正向的操作符，比如用in代替not in；
   5）尽量避免使用or来连接条件，如果使用那么将会全表扫描，就算or前的字段有索引也不会用上；
      索引而进行全表扫描，如：假设 num1 有索引，num2 没有索引，查询语句 select id from t where num1=10 or num2=20 
      会放弃使用索引，可以改为这样查询（union all 将前后语句查询结果联合输出）：
      select id from t where num1=10 union all select id from t where num2=20，
      这样虽然num2没有使用索引，但至少num1会使用索引，提高效率。
   6）尽量使用数字型，查询快还能减少开销；   
   7）尽量不要让字段默认值为NULL，因会使得索引统计信息以及比较运算更复杂，复合索引无效；
      所以我们在数据库设计时尽量不要让字段的默认值为NULL，应该指定列为NOT NULL，除非你想存储NULL。你应该用0、
      一个特殊的值或者一个空串代替空值。
   8）如果列类型是字符串，那么where条件中的字符常量要加引号，如no = '3'用索引，no = 3不会用索引（隐式转换问题）；
   9）慎用insert into select。
     语句：insert into tableA select * from tableB where date_time > '2020-07-31'；
     问题分析：
     该语句会导致tableB逐步被锁定，其他操作无法进行的问题。
     解决方案：data_time字段添加索引  
   10）索引null值问题
     a、唯一索引null值
        唯一索引中允许存在多行值为NULL的数据存在
        联合唯一索引中存在null值，将丢失唯一性，如unique key(email,phone)，若phone为空将导致email相同的
        多条记录（也就是不能约束某一列为空）存在；
        对NULL值的检索只能使用is null/is not null/<=>，不能使用=,<,>这样的运算符；
     b、普通索引null值
        null值存在仍然可以走索引；
   11）MySQL存储金额
     int or double?
     why?
     分析：double在计算时会丢失精度，浮点型计算机处理不友好
     解决方案：
     用int扩大100倍存储（精确到分）比如金额0.99，存的时候就存99，扩大100倍存储，输出时再转回来就行。
     
   那这个int[M]中M是什么意思？在定义数值型数据类型的时候，可以在关键字括号内指定整数值（如：int(M)，M的最大值为255）
     表示最大显示宽度，显示宽度M与数据所占用空间数值的范围无关。如果在定义字段的时候指定zerofill，那么当数值的显示
     宽度小于指定的列宽度时候，则默认补充的空格用0代替。                 