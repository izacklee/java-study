2021.3.14
#### 1 MySQL索引及查询优化
   数据库的索引是存在磁盘上的，索引的本质是加快查询。主键本身就是一个索引，主键索引。InnoDB（因为数据就是根据主键
   存的）要求必须要求主键（值尽可能小，因为大会占用比较大的空间，能存储的个数就少了，高度就会增加，结果就需要一层层遍历，
   导致查找过于频繁效率低下），若无将自动创建。
   为什么要用索引？因为随着业务增大，每天产生的数据都会很多，在这样的情况下我们怎么保证SQL的执行效率，想要执行得快，
   那必须要用索引以及对SQL进行优化。
   索引为何能提高执行效率？类似书中的目录，通过看目录就能快速定位到想看的内容了，而数据库索引也是一样的，通过索引就能
   快速筛选出期望的数据行，而不需要全部查询筛选。
   B-Tree（既存节点又存数据）树不适合做索引：
    1）因为某一个节点所占的内存大小是固定的，如果搞得特别大（数据大），那么速度就会降低，存的数据也就越少，结果会增加
       树的高度，造成磁盘查找过于频繁效率低下。
    2）范围搜索，需要一层层遍历，非常繁琐（最快时比B+Tree快，因为B-Tree也是将数据存在叶子节点的，知道索引就可以
       直接取到对应索引下的值，而B+Tree则不管在哪个节点，最终都要找到子节点后才能取到数据；最慢时比B+tree慢，要一层层
       全部遍历）
   所以MySQL不采用B-Tree，而是采用了B+Tree，因为这个B+Tree解决了上面B-Tree的两个问题。
   B+Tree存的是索引，而不是数据，而原始的数据是存在它的叶子节点的（所以有了索引 可根据所以快速定位找到索引下的数据）。 
#### 2 B+Tree核心特点
  1）多路非二叉
  2）只有叶子节点保存数据
  3）搜索时相当于二分查找（左小右大）
  4）增加了相邻节点的指向指针（好处：只要知道某一个节点，就可以按顺序依次遍历出来） 
#### 3 MySQL InnoDB普通索引
  1）叶子节点存放的主键，而不是行的物理地址（因为物理地址可能随着数据的增加而变化，但是存主键ID是不会变的）
  2）需要两次检索：a 检索主键；b 根据主键检索数据
  3）存主键好处：页分裂或数据变动时不需要变动
  4）主键设计尽可能小，原因：每个索引都会存，过大浪费空间
  5）主键最好有序，减少索引维护开销
  MySQL InnoDB页的大小是：16k
  MySQL中高度为3的B+Tree大概能存2千万条数据。
#### 4 高性能索引策略
  1）索引选择性：指不重复的索引个数（X,X<=T）和数据表的记录总数（T）的比值，范围在X/T到1之间。索引的选择性越高则查询
    效率越高。唯一索引的X=T，其选择性为1，所以唯一索引的性能最好。
    例如：一张用户表字段：姓名，性别...
        其中性别是不适合做索引的，因为只有两种类别，要么男，要么女。不重复的索引个数X就为2，假设共有100万个用户，
        那么数据表的记录总数T就为100万，索引的选择性 = 2/100w = 0.000002 值很小，几乎忽略，没意义，因此不适合做索引。     
   实际应用场景中索引的选择性与整个列的选择性尽量接近最好。选择性范围在X/T到1之间，没有固定的值到多少才可用索引，
      只要不太小就可测试看加索引与不加索引效率，最后取最优。
  2）前缀索引：对于BLOB，TEXT，或者很长的VARCHAR类型的列，当这个值长度很大又必须利用其进行查询时，就必须使用这个列的
   前几位值以作索引，即前缀索引，因为整个列的值当做索引时B+tree会占用非常大的空间，查找也不方便。
     前缀索引的制定原则：
     前缀索引的选择性需要和整个列的选择性接近，这样性能不会影响太多，同时还不能太长而占用太多空间。
     如何寻找最佳前缀索引？参考文章：https://www.cnblogs.com/balfish/p/9003794.html
  3）多例索引：
     select x,y,z from table where x=1 and y=1;
     在Mysql执行查询时，如果是使用多列索引key(x,y)，则会先查询符合第一列索引的数据集，
     然后再在这一部分数据集中查询出符合第二列的数据，以此类推，这样在不用扫描数据的情况下就能选出数据；
     而如果一个多列索引拆分成多个单列索引(key(x),key(y))的话，Mysql在执行查询时，只会从中选出一个限制最严格的索引
     以供使用，其他的索引就浪费了，所以在上述情况中多列索引性能要好。   
  4）索引顺序：
    select x,y,z from table where x=1 and y=1;
    x=1 and y=1还是y=1 and x=1?
    将选择性高的索引列放在前面；索引列按照选择性从高到低放置（左侧原则，从范围小到大）。
  5）覆盖索引：
    如果一个索引包含了所有需要查询的字段的值，就称之为“覆盖索引”（可考虑把所有字段建成一个索引）。
    InnoDB存储引擎使用聚簇索引，覆盖索引可避免回表查询。因为InnoDB的二级索引的B-Tree的叶结点存储的是对应的一级索引，
  所以如果二级索引覆盖了所要查询的值则会少一次利用一级索引查询，提升效率。
    当发起一个索引覆盖查询时，在执行计划的Extra列中可见“Using index”的信息。
    例句：比如给std_no建了索引为idx_std_no
        EXPLAIN SELECT * FROM test.t_student WHERE std_no=100;  // 查询字段为*，则Extra为NULL
        // 查询字段为std_no，则Extra列中可见“Using index”，因索引包含的所有要查的字段，则就为覆盖索引，可避免回表查询。
        // 这也就是为什么查询语句尽量写清所需查询字段而避免使用*的一个原因，因为写清字段，有可能可避免回表查，提高效率。
        EXPLAIN SELECT std_no FROM test.t_student WHERE std_no=100;  
  6）索引的一些问题：
    6.1）索引越多越好?
      数据更新时需要维护索引，带来开销，按需创建。
    6.2）哪些列适合建索引？
      选择性较高的列，一些常量和枚举的字段（如：性别）不适合建索引，选择性较低还增加维护成本，得不偿失。
    6.3）索引字段类型？
      自增字段，表比较大时，uuid等没有规律的字段不太适合作为主键。
   